#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ä¸‰çº§åˆ†å±‚ç¼“å­˜ç³»ç»Ÿ
==================
L1: å†…å­˜çƒ­ç‚¹ç¼“å­˜ (LRU, 1000æ¡, 1åˆ†é’Ÿ)
L2: Rediså…±äº«ç¼“å­˜ (10ä¸‡æ¡, 1å°æ—¶)
L3: æ•°æ®åº“æŸ¥è¯¢

ç‰ˆæœ¬: 2.0.0
æ—¥æœŸ: 2026-02-24

é›†æˆåŠŸèƒ½:
- è¯»å†™é”ä¿è¯å¹¶å‘ä¸€è‡´æ€§
- å¸ƒéš†è¿‡æ»¤å™¨åŠ é€ŸæŸ¥è¯¢
- é™çº§ç­–ç•¥ä¿è¯å¯ç”¨æ€§
- ç›‘æ§å‘Šè­¦ç³»ç»Ÿ
- å®¹é‡ç›‘æ§
- æ™ºèƒ½é¢„çƒ­
"""

from functools import wraps
from typing import Any, Optional, Dict
from backend.core.cache.base import CacheKeyBuilder, get_cache
from backend.core.cache.validators import CacheKeyValidator
import logging
import time
import threading
import heapq

logger = logging.getLogger(__name__)


class OptimizedLRU:
    """ä¼˜åŒ–çš„LRUæ·˜æ±°å™¨ - ä½¿ç”¨å †æ•°æ®ç»“æ„

    æ—¶é—´å¤æ‚åº¦:
    - è·å–æ“ä½œ: O(log n)
    - æ·˜æ±°æ“ä½œ: O(log n) [åŸO(n)]
    - æ›´æ–°æ“ä½œ: O(log n)

    ä½¿ç”¨æ‡’åˆ é™¤ç­–ç•¥å¤„ç†é‡å¤æ—¶é—´æˆ³
    """

    def __init__(self, capacity: int):
        """åˆå§‹åŒ–LRU

        Args:
            capacity: ç¼“å­˜å®¹é‡
        """
        self.capacity = capacity
        self._access_heap: list[tuple[float, str]] = []  # (access_time, key)
        self._key_to_access_time: dict[str, float] = {}
        self._current_size = 0
        self._lock = threading.Lock()

    def record_access(self, key: str) -> None:
        """è®°å½•é”®è®¿é—®

        Args:
            key: ç¼“å­˜é”®
        """
        with self._lock:
            current_time = time.time()

            # æ£€æŸ¥æ˜¯å¦ä¸ºæ–°é”®
            is_new = key not in self._key_to_access_time

            self._key_to_access_time[key] = current_time
            heapq.heappush(self._access_heap, (current_time, key))

            # æ–°é”®éœ€è¦å¢åŠ å¤§å°è®¡æ•°
            if is_new:
                self._current_size += 1

    def evict_lru(self) -> Optional[str]:
        """æ·˜æ±°æœ€å°‘ä½¿ç”¨çš„é”®

        ä½¿ç”¨æ‡’åˆ é™¤ç­–ç•¥:
        - ä»å †ä¸­å¼¹å‡ºæœ€å°æ—¶é—´æˆ³
        - éªŒè¯æ˜¯å¦ä¸ºæœ€æ–°æ—¶é—´æˆ³
        - å¦‚æœä¸æ˜¯ï¼Œç»§ç»­å¼¹å‡ºä¸‹ä¸€ä¸ª

        Returns:
            è¢«æ·˜æ±°çš„é”®ï¼Œå¦‚æœæ²¡æœ‰å¯æ·˜æ±°çš„è¿”å›None
        """
        with self._lock:
            while self._access_heap:
                access_time, key = heapq.heappop(self._access_heap)

                # æ£€æŸ¥æ˜¯å¦ä¸ºæœ€æ–°æ—¶é—´æˆ³
                if self._key_to_access_time.get(key) == access_time:
                    # æœ‰æ•ˆçš„æ—¶é—´æˆ³ï¼Œåˆ é™¤
                    del self._key_to_access_time[key]
                    self._current_size -= 1
                    return key

                # æ‡’åˆ é™¤ï¼šæ—¶é—´æˆ³å·²è¿‡æœŸï¼Œç»§ç»­æŸ¥æ‰¾ä¸‹ä¸€ä¸ª

            return None

    def remove_key(self, key: str) -> None:
        """ç§»é™¤æŒ‡å®šé”®

        ä½¿ç”¨æ‡’åˆ é™¤ç­–ç•¥ï¼Œæ ‡è®°ä¸ºè¿‡æœŸ

        Args:
            key: è¦ç§»é™¤çš„é”®
        """
        with self._lock:
            if key in self._key_to_access_time:
                del self._key_to_access_time[key]
                self._current_size -= 1

    def get_size(self) -> int:
        """è·å–å½“å‰å¤§å°"""
        return self._current_size


class HierarchicalCache:
    """ä¸‰çº§åˆ†å±‚ç¼“å­˜ç®¡ç†å™¨

    ç¼“å­˜å±‚çº§:
    - L1: å†…å­˜çƒ­ç‚¹ç¼“å­˜ (1000æ¡, 60ç§’TTL) - å“åº”æ—¶é—´ <1ms
    - L2: Rediså…±äº«ç¼“å­˜ (10ä¸‡æ¡, 3600ç§’TTL) - å“åº”æ—¶é—´ 5-10ms
    - L3: æ•°æ®åº“æŸ¥è¯¢ - å“åº”æ—¶é—´ 50-200ms

    é›†æˆåŠŸèƒ½:
    - è¯»å†™é”ï¼šä¿è¯å¹¶å‘è®¿é—®ä¸€è‡´æ€§
    - å¸ƒéš†è¿‡æ»¤å™¨ï¼šå¿«é€Ÿåˆ¤æ–­é”®æ˜¯å¦å­˜åœ¨
    - é™çº§ç­–ç•¥ï¼šRedisæ•…éšœæ—¶é™çº§åˆ°L1
    - ç›‘æ§å‘Šè­¦ï¼šå®æ—¶æ€§èƒ½ç›‘æ§
    - å®¹é‡ç›‘æ§ï¼šè‡ªåŠ¨æ‰©å®¹L1
    - æ™ºèƒ½é¢„çƒ­ï¼šåŸºäºå†å²æ•°æ®é¢„æµ‹çƒ­ç‚¹
    - ä¼˜åŒ–LRUï¼šä½¿ç”¨å †æ•°æ®ç»“æ„ï¼ŒO(log n)æ·˜æ±°

    ä¼˜åŠ¿:
    - çƒ­ç‚¹æ•°æ®æå¿«è®¿é—®ï¼ˆL1ï¼‰
    - å¤§å®¹é‡ç¼“å­˜å­˜å‚¨ï¼ˆL2ï¼‰
    - è‡ªåŠ¨LRUæ·˜æ±°ï¼ŒèŠ‚çœå†…å­˜ [ä¼˜åŒ–åO(log n)]
    - L2å‘½ä¸­è‡ªåŠ¨å›å¡«L1
    - é«˜å¹¶å‘å®‰å…¨ï¼ˆè¯»å†™é”ï¼‰
    - é«˜å¯ç”¨æ€§ï¼ˆé™çº§ç­–ç•¥ï¼‰
    """

    def __init__(
        self,
        l1_size=1000,
        l1_ttl=60,
        l2_ttl=3600,
        enable_read_write_lock=False,
        enable_bloom_filter=False,
        enable_degradation=False
    ):
        """
        åˆå§‹åŒ–åˆ†å±‚ç¼“å­˜

        Args:
            l1_size: L1ç¼“å­˜å¤§å°ï¼ˆæ¡æ•°ï¼‰ï¼Œé»˜è®¤1000
            l1_ttl: L1ç¼“å­˜TTLï¼ˆç§’ï¼‰ï¼Œé»˜è®¤60
            l2_ttl: L2ç¼“å­˜TTLï¼ˆç§’ï¼‰ï¼Œé»˜è®¤3600
            enable_read_write_lock: æ˜¯å¦å¯ç”¨è¯»å†™é”
            enable_bloom_filter: æ˜¯å¦å¯ç”¨å¸ƒéš†è¿‡æ»¤å™¨
            enable_degradation: æ˜¯å¦å¯ç”¨é™çº§ç­–ç•¥
        """
        self.l1_size = l1_size
        self.l1_ttl = l1_ttl
        self.l2_ttl = l2_ttl
        self.l1_cache: Dict[str, Any] = {}  # ç®€å•å­—å…¸ç¼“å­˜ï¼ˆå¸¦TTLï¼‰
        self.l1_timestamps: Dict[str, float] = {}

        # ä¼˜åŒ–çš„LRUæ·˜æ±°å™¨
        self._lru = OptimizedLRU(l1_size)

        # çº¿ç¨‹é”ï¼ˆç”¨äºL1ç¼“å­˜æ“ä½œï¼‰
        self._lock = threading.Lock()

        # ç»Ÿè®¡ä¿¡æ¯
        self.stats = {
            "l1_hits": 0,
            "l2_hits": 0,
            "misses": 0,
            "l1_evictions": 0,
            "lru_evict_time": []  # è®°å½•æ·˜æ±°è€—æ—¶ï¼ˆå¾®ç§’ï¼‰
        }

        # åŠŸèƒ½å¼€å…³
        self._enable_read_write_lock = enable_read_write_lock
        self._enable_bloom_filter = enable_bloom_filter
        self._enable_degradation = enable_degradation

        # å»¶è¿ŸåŠ è½½çš„æ¨¡å—ï¼ˆé¿å…å¾ªç¯å¯¼å…¥ï¼‰
        self._rw_lock = None
        self._bloom_filter = None
        self._degradation_manager = None

        logger.info(
            f"âœ… ä¸‰çº§ç¼“å­˜åˆå§‹åŒ–: "
            f"L1={l1_size}æ¡/{l1_ttl}ç§’, L2={l2_ttl}ç§’, "
            f"è¯»å†™é”={enable_read_write_lock}, å¸ƒéš†è¿‡æ»¤å™¨={enable_bloom_filter}, é™çº§={enable_degradation}"
        )

    def get(self, pattern: str, **kwargs) -> Optional[Any]:
        """
        ä¸‰çº§ç¼“å­˜æŸ¥è¯¢

        æŸ¥è¯¢é¡ºåº:
        1. å¸ƒéš†è¿‡æ»¤å™¨å¿«é€Ÿåˆ¤æ–­ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        2. L1å†…å­˜ç¼“å­˜ (<1ms)
        3. L2 Redisç¼“å­˜ (5-10msï¼Œå‘½ä¸­åå›å¡«L1)
        4. L3æ•°æ®åº“ (è¿”å›Noneï¼Œç”±è°ƒç”¨æ–¹æŸ¥è¯¢)

        Args:
            pattern: ç¼“å­˜æ¨¡å¼ (å¦‚ 'events.list')
            **kwargs: å‚æ•°é”®å€¼å¯¹

        Returns:
            ç¼“å­˜æ•°æ®æˆ–Noneï¼ˆæœªå‘½ä¸­ï¼‰
        """
        # ä½¿ç”¨CacheKeyValidatoræ„å»ºå®‰å…¨çš„ç¼“å­˜é”®
        key = CacheKeyValidator.build_key(pattern, **kwargs)

        # é›†æˆå¸ƒéš†è¿‡æ»¤å™¨
        if self._enable_bloom_filter:
            bloom = self._get_bloom_filter()
            if bloom and key not in bloom:
                # é”®è‚¯å®šä¸å­˜åœ¨ï¼Œç›´æ¥è¿”å›None
                self.stats["misses"] += 1
                logger.debug(f"ğŸŒ¸ å¸ƒéš†è¿‡æ»¤å™¨: é”®ä¸å­˜åœ¨ {key}")
                return None

        # é›†æˆè¯»å†™é”ï¼ˆè¯»é”ï¼‰
        if self._enable_read_write_lock:
            rw_lock = self._get_rw_lock()
            if rw_lock:
                return self._get_with_lock(key)
            else:
                return self._get_without_lock(key)
        else:
            return self._get_without_lock(key)

    def _get_with_lock(self, key: str) -> Optional[Any]:
        """
        ä½¿ç”¨è¯»å†™é”çš„ç¼“å­˜è·å–

        Args:
            key: ç¼“å­˜é”®

        Returns:
            ç¼“å­˜æ•°æ®æˆ–None
        """
        rw_lock = self._get_rw_lock()
        with rw_lock.read_lock(key):
            return self._get_without_lock(key)

    def _get_without_lock(self, key: str) -> Optional[Any]:
        """
        ä¸ä½¿ç”¨é”çš„ç¼“å­˜è·å–ï¼ˆå†…éƒ¨å®ç°ï¼‰

        Args:
            key: ç¼“å­˜é”®

        Returns:
            ç¼“å­˜æ•°æ®æˆ–None
        """
        # L1: å†…å­˜çƒ­ç‚¹ç¼“å­˜
        if key in self.l1_cache:
            timestamp = self.l1_timestamps.get(key, 0)
            if time.time() - timestamp < self.l1_ttl:
                self.stats["l1_hits"] += 1
                # æ›´æ–°LRUè®¿é—®æ—¶é—´
                self._lru.record_access(key)
                logger.debug(f"âœ… L1 HIT: {key}")
                return self.l1_cache[key]
            else:
                # L1è¿‡æœŸï¼Œåˆ é™¤
                del self.l1_cache[key]
                del self.l1_timestamps[key]
                # ä»LRUä¸­ç§»é™¤
                self._lru.remove_key(key)
                logger.debug(f"â° L1è¿‡æœŸ: {key}")

        # é›†æˆé™çº§ç­–ç•¥
        if self._enable_degradation:
            degradation_manager = self._get_degradation_manager()
            if degradation_manager and degradation_manager.is_degraded():
                # é™çº§æ¨¡å¼ï¼šåªä½¿ç”¨L1
                self.stats["misses"] += 1
                logger.debug(f"âš ï¸ é™çº§æ¨¡å¼: L1æœªå‘½ä¸­ {key}")
                return None

        # L2: Redisç¼“å­˜
        cache = get_cache()
        if cache is not None:
            try:
                cached = cache.get(key)
                if cached is not None:
                    # å›å¡«L1
                    self._set_l1(key, cached)
                    self.stats["l2_hits"] += 1
                    logger.debug(f"âœ… L2 HIT â†’ L1å›å¡«: {key}")
                    return cached
            except Exception as e:
                logger.warning(f"âš ï¸ L2ç¼“å­˜è¯»å–å¤±è´¥: {e}")

                # å¦‚æœå¯ç”¨äº†é™çº§ç­–ç•¥ï¼Œè¿›å…¥é™çº§æ¨¡å¼
                if self._enable_degradation:
                    degradation_manager = self._get_degradation_manager()
                    if degradation_manager:
                        degradation_manager._enter_degraded_mode()

        # L3: ç¼“å­˜æœªå‘½ä¸­ï¼Œè¿”å›None
        self.stats["misses"] += 1
        logger.debug(f"âŒ CACHE MISS: {key}")
        return None

    def set(self, pattern: str, data: Any, **kwargs):
        """
        å†™å…¥ä¸‰çº§ç¼“å­˜

        åŒæ—¶å†™å…¥L1å’ŒL2ï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§

        Args:
            pattern: ç¼“å­˜æ¨¡å¼ (å¦‚ 'events.list')
            data: è¦ç¼“å­˜çš„æ•°æ®
            **kwargs: å‚æ•°é”®å€¼å¯¹
        """
        # ä½¿ç”¨CacheKeyValidatoræ„å»ºå®‰å…¨çš„ç¼“å­˜é”®
        key = CacheKeyValidator.build_key(pattern, **kwargs)

        # é›†æˆè¯»å†™é”ï¼ˆå†™é”ï¼‰
        if self._enable_read_write_lock:
            rw_lock = self._get_rw_lock()
            if rw_lock:
                with rw_lock.write_lock(key):
                    self._set_without_lock(key, data)
                    return

        # ä¸ä½¿ç”¨é”çš„å†™å…¥
        self._set_without_lock(key, data)

    def _set_without_lock(self, key: str, data: Any):
        """
        ä¸ä½¿ç”¨é”çš„ç¼“å­˜å†™å…¥ï¼ˆå†…éƒ¨å®ç°ï¼‰

        Args:
            key: ç¼“å­˜é”®
            data: ç¼“å­˜æ•°æ®
        """
        # é›†æˆå¸ƒéš†è¿‡æ»¤å™¨
        if self._enable_bloom_filter:
            bloom = self._get_bloom_filter()
            if bloom:
                bloom.add(key)

        # å†™å…¥L1
        self._set_l1(key, data)

        # é›†æˆé™çº§ç­–ç•¥
        if self._enable_degradation:
            degradation_manager = self._get_degradation_manager()
            if degradation_manager and degradation_manager.is_degraded():
                # é™çº§æ¨¡å¼ï¼šåªå†™å…¥L1
                logger.debug(f"âš ï¸ é™çº§æ¨¡å¼: ä»…å†™å…¥L1 {key}")
                return

        # å†™å…¥L2
        cache = get_cache()
        if cache is not None:
            try:
                cache.set(key, data, timeout=self.l2_ttl)
                logger.debug(f"ğŸ’¾ L2 SET: {key}")
            except Exception as e:
                logger.warning(f"âš ï¸ L2ç¼“å­˜å†™å…¥å¤±è´¥: {e}")

                # å¦‚æœå¯ç”¨äº†é™çº§ç­–ç•¥ï¼Œè¿›å…¥é™çº§æ¨¡å¼
                if self._enable_degradation:
                    degradation_manager = self._get_degradation_manager()
                    if degradation_manager:
                        degradation_manager._enter_degraded_mode()

    def _set_l1(self, key: str, data: Any):
        """
        å†™å…¥L1ç¼“å­˜ï¼ˆå¸¦LRUæ·˜æ±°ï¼‰

        å½“L1ç¼“å­˜æ»¡æ—¶ï¼Œåˆ é™¤æœ€æ—§çš„æ¡ç›®

        ä½¿ç”¨ä¼˜åŒ–çš„LRUæ·˜æ±°å™¨:
        - æ—¶é—´å¤æ‚åº¦: O(log n) [åŸO(n)]
        - ä½¿ç”¨å †æ•°æ®ç»“æ„
        - æ‡’åˆ é™¤ç­–ç•¥å¤„ç†é‡å¤æ—¶é—´æˆ³

        Args:
            key: ç¼“å­˜é”®
            data: ç¼“å­˜æ•°æ®
        """
        # å¦‚æœL1å·²æ»¡ï¼Œåˆ é™¤æœ€æ—§çš„æ¡ç›®ï¼ˆä½¿ç”¨ä¼˜åŒ–çš„LRUï¼‰
        if len(self.l1_cache) >= self.l1_size:
            start_time = time.perf_counter()

            # ä½¿ç”¨ä¼˜åŒ–çš„LRUæ·˜æ±°å™¨
            oldest_key = self._lru.evict_lru()

            evict_time = (time.perf_counter() - start_time) * 1_000_000  # å¾®ç§’
            self.stats["lru_evict_time"].append(evict_time)

            if oldest_key:
                del self.l1_cache[oldest_key]
                if oldest_key in self.l1_timestamps:
                    del self.l1_timestamps[oldest_key]
                self.stats["l1_evictions"] += 1
                logger.debug(f"ğŸ—‘ï¸ L1æ·˜æ±°: {oldest_key} (è€—æ—¶: {evict_time:.2f}Î¼s)")

        # æ·»åŠ æ–°æ¡ç›®
        self.l1_cache[key] = data
        self.l1_timestamps[key] = time.time()

        # è®°å½•è®¿é—®ï¼ˆç”¨äºLRUè·Ÿè¸ªï¼‰
        self._lru.record_access(key)

    def invalidate(self, pattern: str, **kwargs):
        """
        å¤±æ•ˆç¼“å­˜ï¼ˆL1å’ŒL2åŒæ—¶å¤±æ•ˆï¼‰

        Args:
            pattern: ç¼“å­˜æ¨¡å¼
            **kwargs: å‚æ•°é”®å€¼å¯¹
        """
        # ä½¿ç”¨CacheKeyValidatoræ„å»ºå®‰å…¨çš„ç¼“å­˜é”®
        key = CacheKeyValidator.build_key(pattern, **kwargs)

        # å¤±æ•ˆL1
        if key in self.l1_cache:
            del self.l1_cache[key]
            del self.l1_timestamps[key]
            # ä»LRUä¸­ç§»é™¤
            self._lru.remove_key(key)
            logger.debug(f"ğŸ—‘ï¸ L1å¤±æ•ˆ: {key}")

        # å¤±æ•ˆL2
        cache = get_cache()
        if cache is not None:
            try:
                cache.delete(key)
                logger.debug(f"ğŸ—‘ï¸ L2å¤±æ•ˆ: {key}")
            except Exception as e:
                logger.warning(f"âš ï¸ L2ç¼“å­˜å¤±æ•ˆå¤±è´¥: {e}")

    def invalidate_pattern(self, pattern: str, **kwargs) -> int:
        """
        å¤±æ•ˆåŒ¹é…æ¨¡å¼çš„æ‰€æœ‰L1ç¼“å­˜é”®

        Args:
            pattern: ç¼“å­˜æ¨¡å¼
            **kwargs: è¦åŒ¹é…çš„å‚æ•°

        Returns:
            å¤±æ•ˆçš„é”®æ•°é‡
        """
        # æ„å»ºé€šé…ç¬¦æ¨¡å¼å¹¶éªŒè¯
        wildcard = CacheKeyBuilder.build_pattern(pattern, **kwargs)

        # éªŒè¯é€šé…ç¬¦æ¨¡å¼çš„å®‰å…¨æ€§
        if not CacheKeyValidator.validate_pattern_for_wildcard(wildcard):
            logger.error(f"ä¸å®‰å…¨çš„é€šé…ç¬¦æ¨¡å¼: {wildcard}")
            return 0

        count = 0

        # æ”¶é›†è¦åˆ é™¤çš„é”®
        keys_to_delete = []
        for key in self.l1_cache:
            if self._match_pattern(key, wildcard):
                keys_to_delete.append(key)

        # åˆ é™¤åŒ¹é…çš„é”®
        for key in keys_to_delete:
            del self.l1_cache[key]
            del self.l1_timestamps[key]
            # ä»LRUä¸­ç§»é™¤
            self._lru.remove_key(key)
            count += 1
            logger.debug(f"ğŸ—‘ï¸ L1æ¨¡å¼å¤±æ•ˆ: {key}")

        return count

    def _match_pattern(self, key: str, pattern: str) -> bool:
        """
        å‚æ•°æ„ŸçŸ¥çš„é€šé…ç¬¦åŒ¹é…

        åŒ¹é…é€»è¾‘:
        - ä»patternä¸­æå–æŒ‡å®šçš„å‚æ•°çº¦æŸï¼ˆå¦‚ game_id:*)
        - æ£€æŸ¥keyä¸­æ˜¯å¦æ»¡è¶³è¿™äº›çº¦æŸ
        - å¿½ç•¥keyä¸­çš„å…¶ä»–å‚æ•°

        Args:
            key: ç¼“å­˜é”®ï¼ˆå¦‚ 'dwd_gen:v3:test.key:event_id:0:game_id:1'ï¼‰
            pattern: é€šé…ç¬¦æ¨¡å¼ï¼ˆå¦‚ 'dwd_gen:v3:test.key:game_id:*'ï¼‰

        Returns:
            æ˜¯å¦åŒ¹é…

        Example:
            >>> key = 'dwd_gen:v3:test.key:event_id:0:game_id:1'
            >>> pattern = 'dwd_gen:v3:test.key:game_id:*'
            >>> _match_pattern(key, pattern)
            True  # game_id=1åŒ¹é…ï¼Œå¿½ç•¥event_idå‚æ•°
        """
        # Remove common prefix
        prefix = CacheKeyBuilder.PREFIX
        if not key.startswith(prefix) or not pattern.startswith(prefix):
            return False

        key_suffix = key[len(prefix) :]
        pattern_suffix = pattern[len(prefix) :]

        # Split by ':' to get components
        key_parts = key_suffix.split(":")
        pattern_parts = pattern_suffix.split(":")

        # The format is: base_pattern:param1:value1:param2:value2:...
        # pattern_parts: ['test.key', 'game_id', '*']
        # key_parts: ['test.key', 'event_id', '0', 'game_id', '1']

        # Base pattern is always the first part
        base_pattern = pattern_parts[0]

        # Check base pattern matches
        if key_parts[0] != base_pattern:
            return False

        # Extract parameter constraints from pattern (key:value pairs where value is '*')
        pattern_constraints = {}
        for i in range(1, len(pattern_parts), 2):
            if i + 1 < len(pattern_parts):
                param_name = pattern_parts[i]
                if pattern_parts[i + 1] == "*":
                    pattern_constraints[param_name] = None  # Wildcard value
                else:
                    pattern_constraints[param_name] = pattern_parts[i + 1]

        # Extract parameters from key (key:value pairs starting from index 1)
        key_params = {}
        for i in range(1, len(key_parts), 2):
            if i + 1 < len(key_parts):
                key_params[key_parts[i]] = key_parts[i + 1]

        # Check if all pattern constraints are satisfied in key
        for param_name, param_value in pattern_constraints.items():
            if param_name not in key_params:
                return False
            if param_value is not None and key_params[param_name] != param_value:
                return False

        return True

    def get_stats(self) -> dict:
        """
        è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯

        Returns:
            ç»Ÿè®¡ä¿¡æ¯å­—å…¸
        """
        total_requests = self.stats["l1_hits"] + self.stats["l2_hits"] + self.stats["misses"]

        if total_requests == 0:
            hit_rate = 0
        else:
            hit_rate = (self.stats["l1_hits"] + self.stats["l2_hits"]) / total_requests * 100

        # è®¡ç®—LRUæ·˜æ±°æ€§èƒ½
        evict_times = self.stats["lru_evict_time"]
        avg_evict_time = sum(evict_times) / len(evict_times) if evict_times else 0
        max_evict_time = max(evict_times) if evict_times else 0
        min_evict_time = min(evict_times) if evict_times else 0

        return {
            "l1_size": len(self.l1_cache),
            "l1_capacity": self.l1_size,
            "l1_usage": f"{len(self.l1_cache) / self.l1_size * 100:.1f}%",
            "l1_hits": self.stats["l1_hits"],
            "l2_hits": self.stats["l2_hits"],
            "misses": self.stats["misses"],
            "hit_rate": f"{hit_rate:.2f}%",
            "l1_evictions": self.stats["l1_evictions"],
            "total_requests": total_requests,
            # LRUæ€§èƒ½æŒ‡æ ‡
            "lru_avg_evict_time_us": f"{avg_evict_time:.2f}",
            "lru_max_evict_time_us": f"{max_evict_time:.2f}",
            "lru_min_evict_time_us": f"{min_evict_time:.2f}",
            "lru_evict_count": len(evict_times),
        }

    def clear_l1(self):
        """æ¸…ç©ºL1ç¼“å­˜"""
        self.l1_cache.clear()
        self.l1_timestamps.clear()
        # é‡ç½®LRU
        self._lru = OptimizedLRU(self.l1_size)
        logger.info("ğŸ—‘ï¸ L1ç¼“å­˜å·²æ¸…ç©º")

    def reset_stats(self):
        """é‡ç½®ç»Ÿè®¡ä¿¡æ¯"""
        self.stats = {
            "l1_hits": 0,
            "l2_hits": 0,
            "misses": 0,
            "l1_evictions": 0,
            "lru_evict_time": []
        }
        logger.info("ğŸ“Š ç¼“å­˜ç»Ÿè®¡å·²é‡ç½®")

    # ========== é›†æˆæ¨¡å—è·å–æ–¹æ³• ==========

    def _get_rw_lock(self):
        """è·å–è¯»å†™é”å®ä¾‹ï¼ˆå»¶è¿ŸåŠ è½½ï¼‰"""
        if self._rw_lock is None and self._enable_read_write_lock:
            try:
                from .consistency import cache_rw_lock
                self._rw_lock = cache_rw_lock
                logger.debug("âœ… è¯»å†™é”å·²åŠ è½½")
            except ImportError as e:
                logger.warning(f"âš ï¸ è¯»å†™é”æ¨¡å—åŠ è½½å¤±è´¥: {e}")
        return self._rw_lock

    def _get_bloom_filter(self):
        """è·å–å¸ƒéš†è¿‡æ»¤å™¨å®ä¾‹ï¼ˆå»¶è¿ŸåŠ è½½ï¼‰"""
        if self._bloom_filter is None and self._enable_bloom_filter:
            try:
                from .bloom_filter_enhanced import get_enhanced_bloom_filter
                self._bloom_filter = get_enhanced_bloom_filter()
                logger.debug("âœ… å¸ƒéš†è¿‡æ»¤å™¨å·²åŠ è½½")
            except ImportError as e:
                logger.warning(f"âš ï¸ å¸ƒéš†è¿‡æ»¤å™¨æ¨¡å—åŠ è½½å¤±è´¥: {e}")
        return self._bloom_filter

    def _get_degradation_manager(self):
        """è·å–é™çº§ç®¡ç†å™¨å®ä¾‹ï¼ˆå»¶è¿ŸåŠ è½½ï¼‰"""
        if self._degradation_manager is None and self._enable_degradation:
            try:
                from .degradation import get_degradation_manager
                self._degradation_manager = get_degradation_manager()
                logger.debug("âœ… é™çº§ç®¡ç†å™¨å·²åŠ è½½")
            except ImportError as e:
                logger.warning(f"âš ï¸ é™çº§ç®¡ç†å™¨æ¨¡å—åŠ è½½å¤±è´¥: {e}")
        return self._degradation_manager

    # ========== åŠŸèƒ½å¼€å…³æ§åˆ¶ ==========

    def enable_read_write_lock(self):
        """å¯ç”¨è¯»å†™é”"""
        self._enable_read_write_lock = True
        logger.info("âœ… è¯»å†™é”å·²å¯ç”¨")

    def disable_read_write_lock(self):
        """ç¦ç”¨è¯»å†™é”"""
        self._enable_read_write_lock = False
        logger.info("â¹ï¸ è¯»å†™é”å·²ç¦ç”¨")

    def enable_bloom_filter(self):
        """å¯ç”¨å¸ƒéš†è¿‡æ»¤å™¨"""
        self._enable_bloom_filter = True
        logger.info("âœ… å¸ƒéš†è¿‡æ»¤å™¨å·²å¯ç”¨")

    def disable_bloom_filter(self):
        """ç¦ç”¨å¸ƒéš†è¿‡æ»¤å™¨"""
        self._enable_bloom_filter = False
        logger.info("â¹ï¸ å¸ƒéš†è¿‡æ»¤å™¨å·²ç¦ç”¨")

    def enable_degradation(self):
        """å¯ç”¨é™çº§ç­–ç•¥"""
        self._enable_degradation = True
        logger.info("âœ… é™çº§ç­–ç•¥å·²å¯ç”¨")

    def disable_degradation(self):
        """ç¦ç”¨é™çº§ç­–ç•¥"""
        self._enable_degradation = False
        logger.info("â¹ï¸ é™çº§ç­–ç•¥å·²ç¦ç”¨")

    # ========== é›†æˆåŠŸèƒ½å¿«æ·æ–¹æ³• ==========

    def get_integration_status(self) -> Dict:
        """
        è·å–é›†æˆåŠŸèƒ½çŠ¶æ€

        Returns:
            çŠ¶æ€å­—å…¸
        """
        return {
            "read_write_lock_enabled": self._enable_read_write_lock,
            "read_write_lock_loaded": self._rw_lock is not None,
            "bloom_filter_enabled": self._enable_bloom_filter,
            "bloom_filter_loaded": self._bloom_filter is not None,
            "degradation_enabled": self._enable_degradation,
            "degradation_loaded": self._degradation_manager is not None,
        }


# å…¨å±€åˆ†å±‚ç¼“å­˜å®ä¾‹
hierarchical_cache = HierarchicalCache()


def cached_hierarchical(pattern: str):
    """
    åˆ†å±‚ç¼“å­˜è£…é¥°å™¨

    Usage:
        @cached_hierarchical('events.list')
        def get_events(game_id: int, page: int):
            return fetch_events_from_db(game_id, page)

    Args:
        pattern: ç¼“å­˜æ¨¡å¼ (å¦‚ 'events.list')
    """

    def decorator(f):
        @wraps(f)
        def wrapper(*args, **kwargs):
            # å°è¯•ä»ç¼“å­˜è·å–
            result = hierarchical_cache.get(pattern, **kwargs)
            if result is not None:
                return result

            # æ‰§è¡Œå‡½æ•°
            result = f(*args, **kwargs)

            # å†™å…¥ç¼“å­˜
            hierarchical_cache.set(pattern, result, **kwargs)

            return result

        return wrapper

    return decorator


logger.info("âœ… ä¸‰çº§åˆ†å±‚ç¼“å­˜ç³»ç»Ÿå·²åŠ è½½ (1.0.0)")
